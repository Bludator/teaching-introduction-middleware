\part{Swagger: RESTful API Generation}


\section{Technology Overview}


\begin{frame}{Motivation}
    \begin{itemize}
        \item Protocol for data transfer and modification.
        \item Secure and reliable.
        \item Easy to deploy.
        \item Separate model from view.
        \item Independent implementation (technology)
            of client and server.
    \end{itemize}
\end{frame}

\begin{frame}{REST: Representational State Transfer}
    \begin{quotation}
        REST-compliant Web services allow requesting systems to access
        and manipulate textual representations of Web resources using
        a uniform and predefined set of stateless operations.
        
        \hfill ... Wikipedia
    \end{quotation}
    
    \bigskip
    
    Practically: each object (e.g. a database record) has its own URL
    and specific URLs for actions upon the objects
    (i.e. data are transferred via HTTP).
    
    \medskip
    
    \texttt{http://example.com/person/42}: get information about the person
    
    \texttt{http://example.com/person/add}: add a new person
    
    \texttt{http://example.com/person/42/update}: update details
    
    \texttt{http://example.com/person/42/delete}: delete the person
\end{frame}


\begin{frame}{REST and CRUD}
    CRUD -- create, read, update, delete -- are typically the minimal set of
    operations available on an object.
    
    \medskip
    
    For RESTful APIs, the correspond with HTTP methods.
    Thus, REST APIs usually distinguish operations by HTTP methods and
    use base object URL.
    
    \medskip
    
    Base URL is e.g. \texttt{http://example.com/person/42}.
    
    \texttt{GET} reads the record.
    
    \texttt{PUT} (or \texttt{POST}) updates the record.
    
    \texttt{DELETE} deletes the record.
    
    Creating (\texttt{PUT} or \texttt{POST}) requires different URL
    (e.g.~\texttt{/person/}), response contains the base URL of the new object.
\end{frame}


\begin{frame}[fragile]{Data Transfer}
    Data exchange format is application specific but usually
    it is JSON because of JavaScript in the browser
    (XML is also a popular option).
    
\begin{lstlisting}[language=json,style=mini]
{
    "name": "Jane Doe",
    "email":  "jane.doe@example.com",
    "url": [
        "http://example.com/~jane.doe/",
        "http://example.com/people/jane.doe/"
    ],
    "address": {
        "street1": "Our Street",
        "stree2": "Street Line #2",
        "city": "The City",
        "postal": "123 00"
    },
    "room": 123
}
\end{lstlisting}
\end{frame}


\begin{frame}{Swagger: RESTful API generation}
    \begin{block}{API description as the central concept}
        \begin{description}
            \item[URLs] classes in the data model (class/object)
            \item[Actions] operations on the data (method)
            \item[Data model] Class description (typed attributes)
            \item[Security] Access rules
            \item[Comments] Detailed description is part of the specification
        \end{description}
    \end{block}
    
    \begin{block}{Code generation}
        Server and client stubs that wraps HTTP communication into
        language/framework-specific constructs.
        
        \medskip
        
        RPC-style (with futures) functions for client and
        callbacks for the server.
        
        \medskip
        
        On-line editor at \url{http://editor2.swagger.io/}.
    \end{block}
\end{frame}


\begin{frame}{Recall: Motivation}
    \begin{itemize}
        \item Protocol for data transfer and modification -- uses HTTP.
        \item Secure and reliable -- can run on HTTPS too.
        \item Easy to deploy -- no special server needed.
        \item Separate model from view -- bare data are transferred.
        \item Independent implementation (technology)
            of client and server -- over 80 supported targets.
    \end{itemize}
\end{frame}


\begin{frame}{https://swagger.io/}

    \begin{block}{Not Covered Here}
        \begin{itemize}
            \item Security (HTTPS, authentication)
            \item Advanced data model specification (polymorphism etc.)
            \item All of supported frameworks
            \item \ldots
        \end{itemize}
    \end{block}
    
    \begin{block}{Caveats}
        \begin{itemize}
            \item Framework-specific renaming (\texttt{CamelCase},
                \texttt{under\_score} etc.)
            \item Per-framework generators differ in user friendliness
            \item \ldots
        \end{itemize}
    \end{block}
    
\end{frame}






\section{Assignment Details}


\begin{frame}{Assignment}
    \begin{block}{RESTful based application for keeping an inventory}
        There are two entities in the system: users and assets.
        Operations (both client and server) with users are already
        prepared for you.
        
        \medskip
        
        Add operations (client and server) for assets.
        Each employee can own multiple assets.
    \end{block}

    \begin{block}{Server (choose one)}
        \begin{itemize}
            \item Flask-based Python implementation.
            \item Spring-based Java implementation.
        \end{itemize}
    \end{block}

    \begin{block}{Client (choose one)}
        \begin{itemize}
            \item Angular-based web application.
            \item Helper scripts in R and Bash.
        \end{itemize}
    \end{block}
\end{frame}


\begin{frame}[fragile]{\texttt{api.yaml} (prologue)}
\begin{lstlisting}[language=]
swagger: 2.0
info:
  description: Inventory database
  version: 1.0.0
  title: Inventory
  termsOfService: ""
  license:
    name: Apache 2.0
    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
host: localhost:8080
basePath: /v1
schemes:
  - http
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\texttt{api.yaml} (list of users)}
\begin{lstlisting}[language=,style=mini]
paths:
  /users:
    get:
      operationId: readUsers
      produces:
        - "application/json"
      responses:
        200:
          schema:
            type: array
            items:
              $ref: "#/definitions/UserBase"

definitions:
  UserBase:
    type: object
    properties:
      id:
        type: integer
      firstname:
        type: string
      lastname:
        type: string
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\texttt{api.yaml} (user details)}
\begin{lstlisting}[language=,style=mini]
  /user/{id}:
    get:
      summary: Basic information about a user.
      operationId: readUser
      parameters:
        - in: path
          name: id
          description: ID of the user.
          required: true
          type: integer
      produces:
        - "application/json"
      responses:
        200:
          description: Successful operation
          schema:
            type: object
            $ref: "#/definitions/User"
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\texttt{api.yaml} (user update)}
\begin{lstlisting}[language=,style=mini]
    post:
      summary: Update existing user.
      operationId: updateUser
      consumes:
        - "application/json"
      produces:
        - "application/json"
      parameters:
        - in: path
          name: id
          description: ID of the user.
          required: true
          type: integer
        - in: body
          name: body
          description: Updated data.
          required: true
          schema:
            $ref: "#/definitions/User"
      responses:
        405:
          description: Invalid input
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{\texttt{api.yaml} (inheritance)}
\begin{lstlisting}[language=,style=mini]
definitions:
  UserBase:
    type: object
    properties:
      id:
        type: integer
      firstname:
        type: string
      lastname:
        type: string
      email:
        type: string
  User:
    allOf:
      - $ref: "#/definitions/UserBase"
      - type: object
        properties:
          homepage:
            type: string
          department:
            type: string
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{\texttt{api.yaml} (assignment)}
    Add operations for CRUD of individual assets.
    
    \medskip
    
    Each user has a list of assets he owns.
    It is up to you whether to decide how the matching
    would be done (\texttt{User} has array of \texttt{Asset},
    \texttt{Asset} has \texttt{owner} field etc.).
\end{frame}


\begin{frame}{Code generation}
    \begin{block}{Running the Swagger code generator}
        \texttt{swagger-codegen generate \textbackslash} \\
        \texttt{~~~ -i api.yaml \textbackslash} \\
        \texttt{~~~ -o output-dir \textbackslash} \\
        \texttt{~~~ -l framework \textbackslash}
    \end{block}
    
    \begin{block}{Assignment}
        Wrapper scripts \texttt{build-\{server,client\}-*.sh}
        (specific version of the generator to ensure correct
        functionality).
        
        \medskip
        
        Run them after updating your \texttt{api.yaml}.
    \end{block}
\end{frame}


\begin{frame}{Flask-based and Spring-based servers}
    \begin{block}{Commonalities}
        \begin{itemize}
            \item No real database, data are kept in-memory
            \item Data flushed to JSON at termination for debugging
                purposes
            \item See \texttt{README} for instructions how to run
                the server
        \end{itemize}
    \end{block}
    
    \begin{block}{Task}
        Extend the servers to handle operations above
        assets too.
    \end{block}
\end{frame}


\begin{frame}[fragile]{Flask-based server}
    \begin{block}{\texttt{swagger\_server/controllers/default\_controller.py}}
\begin{lstlisting}[language=Python,style=mini]
def create_user(body):  # noqa: E501
    """Creates a new user.

    :param body: User to be added.
    :type body: dict | bytes

    :rtype: None
    """
    if connexion.request.is_json:
        body = User.from_dict(connexion.request.get_json())
    return 'do some magic!'
\end{lstlisting}
    \end{block}

    \begin{block}{\texttt{controllers/users.py}}
        Actual implementation on top of in-memory pseudo-database.
    \end{block}
\end{frame}


\begin{frame}[fragile]{Spring-based server}
    \begin{block}{\texttt{src/gen/java/io/swagger/api/UsersApiController.java}}
\begin{lstlisting}[language=Java,style=mini]
public ResponseEntity<Void> createUser(
        @ApiParam(value = "User to be added." ,required=true ) 
        @Valid
        @RequestBody
        User body) {
    String accept = request.getHeader("Accept");
    
    return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
}
\end{lstlisting}
    \end{block}

    \begin{block}{\texttt{src/main/java/io/swagger/api/UsersApiController.java}}
    Actual implementation on top of in-memory pseudo-database.
    \end{block}
\end{frame}


\begin{frame}{Angular-based application}
    \begin{block}{Task}
       Add components for listing all inventory and extend page with
       user's details with a list of his assets.
    \end{block}
    
    \begin{block}{General rules}
        \begin{itemize}
            \item Sources are under \texttt{src/app}
            \item \texttt{*.component.html} contains web-page snippets
                of the component
            \item \texttt{*.component.ts} contains Typescript
                implementation of the component
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Angular-based application}
    \begin{block}{\texttt{app-routing.module.ts}}
        \begin{itemize}
            \item Import all your components
            \item Add new routes to \texttt{routes}
        \end{itemize}
    \end{block}
    
    \begin{block}{\texttt{app.component.html}}
        \begin{itemize}
            \item Items in the topbar.
        \end{itemize}
    \end{block}
\end{frame}


\begin{frame}[fragile]{Angular-based application: reading data from server}
    \begin{block}{\texttt{users/users.component.ts}}
\begin{lstlisting}[style=mini]
export class UsersComponent implements OnInit {
  users: User[];

  constructor(private api: DefaultService) {}

  ngOnInit() {
    this.api.readUsers().subscribe(u => this.users = u);
  }
}
\end{lstlisting}
    \end{block}
    
    \begin{block}{\texttt{users/users.component.html}}
\begin{lstlisting}[style=mini]
<ul>
  <li *ngFor="let user of users">
    <a routerLink="/user/{{user.id}}">{{user.lastname}}, {{user.firstname}}</a>
  </li>
</ul>
\end{lstlisting}
    \end{block}
\end{frame}


\begin{frame}[fragile]{Angular-based application: storing data on server}
    \begin{block}{\texttt{users/user.component.html}}
\begin{lstlisting}[style=mini]
<form (ngSubmit)="save();">
    <label for="user-first-name">First name:</label>
    <input [(ngModel)]="user.firstname" id="user-first-name" />
    ...
    <button type="submit">Save</button>
</form>
\end{lstlisting}
    \end{block}
    
    \begin{block}{\texttt{users/user.component.ts}}
\begin{lstlisting}[style=mini]
export class UserComponent {
  save(): void {
    const id = +this.route.snapshot.paramMap.get('id');
    this.api.updateUser(id, this.user).subscribe();
  }
}
\end{lstlisting}
    \end{block}
\end{frame}




\begin{frame}[fragile]{Bash client}
    \begin{block}{Generated code}
        The generated script \texttt{client.sh} is a thin wrapper above
        cURL doing the actual requests.
        It is a great tool to check that the server works as expected.
    \end{block}
    
    \begin{block}{\texttt{make-check-lists} and \texttt{add-employees.sh}
        scripts}
        
        Downloads list of employees, creates printable version
        of the inventory.
    
        Reads employee list from a CSV, adds them to the database.
    \end{block}
    
    \begin{block}{Task}
        Extend the \texttt{make-check-lists} to include assets listing
        and create a similar script for adding assets.
        
\begin{lstlisting}
asset,price,acquired,owner
Magic wand,42,2017,harry.potter@example.com
...
\end{lstlisting}
    \end{block}
\end{frame}


\begin{frame}[fragile]{Bash client example}
\begin{lstlisting}
./client.sh --silent readUsers | json_reformat

./client.sh --silent readUser id=1

./client.sh createUser \
    firstname==Horatio lastname==Hornblower \
    email==horatio.hornblower@royalnavy.mod.uk \
    department==Navy \
    homepage==https://www.royalnavy.mod.uk/hornblower

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{R client}
    \begin{block}{\texttt{dept-plot.r} script}
        Draws a barplot showing number of employees in each department. 
    \end{block}
    
    \begin{block}{Task}
        Create a similar script that will show total price of
        assets across departments and for each employee.
    \end{block}
\end{frame}

\begin{frame}[fragile]{\texttt{dept-plot.r}}
\begin{lstlisting}[style=mini]
source("init.r")

api <- DefaultApi$new()

all.users.id <- api$read_users()$content$id

department.people.count <- list()

for (i in all.users.id) {
    u <- api$read_user(i)$content
    dept <- u$department
    if (!(dept %in% names(department.people.count))) {
        department.people.count[[ dept ]] <- 0
    }
    
    department.people.count[[ dept ]] <- department.people.count[[ dept ]] + 1
}

barplot(unlist(department.people.count), main="Employee count per department")
\end{lstlisting}
\end{frame}


\begin{frame}{Assignment summary}
    \begin{itemize}
        \item Extend \texttt{api.yaml} with assets-related operations
            and data definitions.
        \item Extend one of the servers (Flask or Spring).
            \begin{itemize}
                \item In-memory data storage is okay.
                \item Implement all CRUD operations and listing
                    (all and per-user).
            \end{itemize}
        \item Extend client -- either Angular or (Bash and R).
            \begin{itemize}
                \item Angular: allow all of CRUD operations on assets
                    and per-user listing.
                \item Bash and R: asset adding script, printable version
                    of asset listing and two plotting scripts.
            \end{itemize}
    \end{itemize}
\end{frame}
